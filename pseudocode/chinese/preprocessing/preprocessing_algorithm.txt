算法：SAMM数据预处理算法

// 数据预处理主流程
数据预处理主函数():
    // 1. 读取Excel标签文件
    excel数据路径 = r'F:\LW\SAMM\SAMM_Micro_FACS_Codes_v2.xlsx'
    标签数据 = 读取Excel标签文件(excel数据路径)
    
    // 2. 验证视频文件
    视频目录 = r'E:\LW\SAMM_videos'
    验证结果 = 验证视频文件存在性(视频目录, 标签数据)
    
    // 3. 检查视频属性
    视频属性 = 检查视频属性(视频目录)
    
    // 4. 检查帧数
    帧数信息 = 检查帧数信息(视频目录)
    
    // 5. 数据格式转换（如果需要）
    // 转换SAMM格式到视频格式
    转换SAMM到视频()
    
    返回 {
        标签数据: 标签数据,
        验证结果: 验证结果,
        视频属性: 视频属性,
        帧数信息: 帧数信息
    }

// 读取Excel标签文件函数
读取Excel标签文件(文件路径):
    尝试:
        // 获取Excel文件的所有工作表
        excel文件 = pd.Excel文件(文件路径)
        工作表名称 = excel文件.工作表名称
        
        // 读取'MICRO_ONLY'工作表，跳过前15行标题信息
        df = excel文件.解析('MICRO_ONLY', 跳过行数=15)
        
        // 重命名列以提高可读性
        df.重命名列({
            df.列名[0]: 'Subject',
            df.列名[1]: 'Filename',
            df.列名[2]: 'OnsetFrame',
            df.列名[3]: 'ApexFrame', 
            df.列名[4]: 'OffsetFrame',
            df.列名[5]: 'Duration',
            df.列名[6]: 'Object',
            df.列名[7]: 'Micro/Exp',
            df.列名[8]: 'FACS',
            df.列名[9]: 'Emotion',
            df.列名[10]: 'Valence',
            df.列名[11]: 'Notes'
        }, inplace=真)
        
        返回 df
    除了 异常 as e:
        打印(f"读取Excel文件错误: {e}")
        返回 空

// 验证视频文件存在性函数
验证视频文件存在性(视频目录, 标签数据):
    结果 = {
        找到的视频: [],
        缺失的视频: []
    }
    
    若 标签数据 不为 空:
        文件名列表 = 标签数据['Filename'].tolist()
        
        对于 文件名 在 文件名列表:
            // 根据情绪类别构建视频路径
            情绪类别 = 标签数据[标签数据['Filename'] == 文件名]['Emotion'].iloc[0]
            视频路径 = os.路径.连接(视频目录, 情绪类别, f'{文件名}.mp4')
            
            若 os.路径.存在(视频路径):
                结果['找到的视频'].添加(视频路径)
            否则:
                结果['缺失的视频'].添加(视频路径)
    
    返回 结果

// 检查视频属性函数
检查视频属性(视频目录):
    属性信息 = []
    
    // 遍历视频目录中的所有子目录（情绪类别）
    情绪类别列表 = os.列表目录(视频目录)
    
    对于 情绪类别 在 情绪类别列表:
        情绪目录 = os.路径.连接(视频目录, 情绪类别)
        若 os.路径.是目录(情绪目录):
            视频文件列表 = [f 对于 f 在 os.列表目录(情绪目录) 若 f.小写().结束于('.mp4')]
            
            对于 视频文件 在 视频文件列表:
                视频路径 = os.路径.连接(情绪目录, 视频文件)
                
                cap = cv2.视频捕获(视频路径)
                若 cap.isOpened() 为 真:
                    总帧数 = 整数(cap.获取(cv2.CAP_PROP_FRAME_COUNT))
                    FPS = cap.获取(cv2.CAP_PROP_FPS)
                    宽度 = 整数(cap.获取(cv2.CAP_PROP_FRAME_WIDTH))
                    高度 = 整数(cap.获取(cv2.CAP_PROP_FRAME_HEIGHT))
                    
                    属性信息.添加({
                        '视频路径': 视频路径,
                        '总帧数': 总帧数,
                        'FPS': FPS,
                        '分辨率': f'{宽度}x{高度}'
                    })
                    
                    cap.释放()
    
    返回 属性信息

// 检查帧数信息函数
检查帧数信息(视频目录):
    帧数信息 = []
    
    // 遍历视频目录中的所有子目录（情绪类别）
    情绪类别列表 = os.列表目录(视频目录)
    
    对于 情绪类别 在 情绪类别列表:
        情绪目录 = os.路径.连接(视频目录, 情绪类别)
        若 os.路径.是目录(情绪目录):
            视频文件列表 = [f 对于 f 在 os.列表目录(情绪目录) 若 f.小写().结束于('.mp4')]
            
            对于 视频文件 在 视频文件列表:
                视频路径 = os.路径.连接(情绪目录, 视频文件)
                
                cap = cv2.视频捕获(视频路径)
                若 cap.isOpened() 为 真:
                    总帧数 = 整数(cap.获取(cv2.CAP_PROP_FRAME_COUNT))
                    
                    帧数信息.添加({
                        '视频文件': 视频文件,
                        '总帧数': 总帧数
                    })
                    
                    cap.释放()
    
    返回 帧数信息

// 转换SAMM到视频格式函数
转换SAMM到视频():
    // 从图像帧创建视频
    SAMM图像目录 = r'F:\LW\SAMM'
    输出视频目录 = r'E:\LW\SAMM_videos'
    
    // 获取所有受试者目录
    受试者列表 = os.列表目录(SAMM图像目录)
    
    对于 受试者 在 受试者列表:
        受试者路径 = os.路径.连接(SAMM图像目录, 受试者)
        若 os.路径.是目录(受试者路径):
            // 获取该受试者的所有视频序列
            序列列表 = os.列表目录(受试者路径)
            
            对于 序列 在 序列列表:
                序列路径 = os.路径.连接(受试者路径, 序列)
                若 os.路径.是目录(序列路径):
                    // 获取该序列的所有图像帧
                    图像文件列表 = []
                    对于 扩展名 在 ['.jpg', '.jpeg', '.png', '.bmp']:
                        图像文件列表.扩展(Path(序列路径).全局(f'*{扩展名}')))
                        图像文件列表.扩展(Path(序列路径).全局(f'*{扩展名.大写()}')))
                    
                    // 按数字顺序排序图像文件
                    图像文件列表 = 排序(图像文件列表, key=lambda x: 整数(''.连接(过滤(字符串.数字, x.名称))))
                    
                    若 长度(图像文件列表) > 0:
                        // 读取第一张图像以获取尺寸
                        第一张图像 = cv2.读取图像(字符串(图像文件列表[0]))
                        高度, 宽度, 通道数 = 第一张图像.形状
                        
                        // 创建视频写入器 (假设30 FPS)
                        输出视频路径 = os.路径.连接(输出视频目录, 序列 + '.mp4')
                        fourcc = cv2.视频写入器_fourcc(*'mp4v')
                        视频写入器 = cv2.视频写入器(输出视频路径, fourcc, 30.0, (宽度, 高度))
                        
                        对于 图像文件 在 图像文件列表:
                            图像 = cv2.读取图像(字符串(图像文件))
                            视频写入器.写入(图像)
                        
                        视频写入器.释放()

// 数据清洗函数
数据清洗(原始数据):
    清洗后数据 = 原始数据.复制()
    
    // 移除空值
    清洗后数据 = 清洗后数据.删除空值()
    
    // 移除重复项
    清洗后数据 = 清洗后数据.删除重复项()
    
    // 数据类型转换
    数值列 = ['OnsetFrame', 'ApexFrame', 'OffsetFrame', 'Duration', 'Valence']
    对于 列 在 数值列:
        若 列 在 清洗后数据.列名:
            清洗后数据[列] = pd.到数值(清洗后数据[列], 错误='强制转换')
    
    // 过滤异常值
    清洗后数据 = 清洗后数据[清洗后数据['Duration'] > 0]  // 持续时间应大于0
    清洗后数据 = 清洗后数据[清洗后数据['OnsetFrame'] >= 0]  // 帧数应非负
    
    返回 清洗后数据

// 数据标准化函数
数据标准化(数据):
    标准化后数据 = 数据.复制()
    
    // 对数值列进行标准化
    数值列 = ['OnsetFrame', 'ApexFrame', 'OffsetFrame', 'Duration']
    对于 列 在 数值列:
        若 列 在 标准化后数据.列名:
            均值 = 标准化后数据[列].均值()
            标准差 = 标准化后数据[列].标准差()
            标准化后数据[列] = (标准化后数据[列] - 均值) / (标准差 + 1e-8)  // 避免除以零
    
    返回 标准化后数据
